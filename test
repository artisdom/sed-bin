#!/bin/sh

# testlib taken from https://github.com/lhoursquentin/clash
c_red="$(printf '\033[1;31m')"
c_green="$(printf '\033[1;32m')"
c_bold="$(printf '\033[1m')"
c_reset="$(printf '\033[0m')"

condition()
{
  nb_args="$#"
  set -- "$@" "$@"
  index=0
  while [ "$index" -lt "$nb_args" ]; do
    if [ "$1" = '--' ]; then
      separator_index="$index"
    fi
    index="$((index + 1))"
    shift
  done
  index=0
  while [ "$index" != "$separator_index" ]; do
    set -- "$@" "$1"
    index="$((index + 1))"
    shift
  done
  shift "$(($# - separator_index))"
  "$@" || return # return for set -e
}

assert() {
  condition_retval=0
  condition "$@" || condition_retval="$?" # for set -e
  if [ "$condition_retval" "$assert_operator" 0 ]; then
    return
  fi

  assertion="$*"
  shift "$((separator_index + 1))"
  {
    [ -t 2 ] && color=true || unset color
    printf '%sError%s - ' "${color+$c_red}" "${color+$c_reset}"
    printf "$@"
    echo
  } >&2
  failed_assertions="$failed_assertions
$assertion
-------------------------------------"
  return 1
}

assert_true() {
  printf '%s -> true\n' "$*"
  assert_operator='='
  assert "$@"
}

assert_false() {
  printf '%s -> false\n' "$*"
  assert_operator='!='
  assert "$@"
}

assert_out() {
  printf '%s\n' "$*"
  out_file="$(mktemp)"
  condition "$@" > "$out_file"
  shift "$((separator_index + 1))"
  output="$(cat "$out_file"; printf x)"
  output="${output%x}"
  rm "$out_file"
  assert_operator='='
  assert [ "$output" = "$*" ] -- 'Output differ'
}

end_tests() {
  [ -t 1 ] && color=true || unset color
  printf '%s================ END ================%s\n' "${color+$c_bold}" "${color+$c_reset}"
  if [ -z "$failed_assertions" ]; then
    printf '%sPASS%s\n' "${color+$c_green}" "${color+$c_reset}"
  else
    printf '%s\n%sFAIL%s\n' "$failed_assertions" "${color+$c_red}" "${color+$c_reset}"
    return 1
  fi
}

# end of testlib

bin=./sed-bin
translator=./par.sed
generated_file=generated.c

trap 'rm -f "$bin_output" "$expected_output"' EXIT
expected_output="$(mktemp)"
bin_output="$(mktemp)"
# toybox, busybox, bsd sed and gnu sed are the most common targets
sed_implementation='sed' # requiring an IFS split rules out default zsh
# --posix is usually for the gnu version
if "$sed_implementation" --posix '' /dev/null 2> /dev/null; then
  sed_implementation="$sed_implementation --posix"
fi

compile_translator() {
  # Tranlate the translator with itself
  "$translator" < "$translator" > "$generated_file" &&
  make -s &&
  # Compiled tranlator should be able to translate the translator and yield the
  # exact same output
  "$bin" < "$translator" > "$bin_output" &&
  diff --side-by-side --suppress-common-lines "$generated_file" "$bin_output"
}

equal_output() {
  echo --------------------------

  printf '%s\n' "$input" | $sed_implementation "$sed_code" > "$expected_output" &&
  printf '%s\n' "$sed_code" | "$translator" > "$generated_file" &&
  make -s &&
  printf '%s\n' "$input" | "$bin" > "$bin_output" &&
  diff --side-by-side "$expected_output" "$bin_output"
}

verify() {
  sed_code="$1"
  input="$2"

  assert_true equal_output "$sed_code" -- "input: $input"
  echo ==========================
}

# Replace by smaller
verify 's/Hell/Y/' 'Hello World'
verify 's/llo W/y w/' 'Hello World'
verify 's/ World/!/' 'Hello World'
# Replace by bigger
verify 's/Hello/What in the/' 'Hello World'
verify 's/o/ what is wrong with this/' 'Hello World'
verify 's/ld/k! Oh no :(/' 'Hello World'
# Replace by same size
verify 's/Hello/Yolo!/' 'Hello World'
verify 's/o/a/' 'Hello World'
verify 's/ld/k!/' 'Hello World'
# With regex
verify 's/[hH]/Well h/' 'Hello World'
verify 's/. ./a-w/' 'Hello World'
verify 's/o.*/!/' 'Hello World'
verify 's/.*//' 'Hello World'
verify 's/.*/Bye/' 'Hello World'
verify 's/[Hh]ello.* World*//' 'Hello World'
verify 's/Hello World/Bye/' 'Hello World'
verify 's/Hello World//' 'Hello World'
# Fail
verify 's/xz/nope/' 'Hello World'
# Back refs
verify 's/\([^ ]*\)/\1! \1/' 'Hello World'
verify 's/\([^ ]*\) \(.\)/\1! \2 /' 'Hello World'
verify 's/.*r/& & &/' 'Hello World'
verify 's/Hello/\& literal ampersand/' 'Hello World'
# g opt
verify 's/o/a/g' 'Hello World'
verify 's/o/abocde/g' 'Hello World'
verify 's/o/ yo/g' 'Hello World'
verify 's/damn/no/g' 'Oh damn god damnit'
verify 's/damn/n/g' 'Oh damn god damnit'
verify 's/.*/Bye/g' 'Hello World'
verify 's/\([^ ]*\)/\1! \1/g' 'Hello World'
verify 's/[^a]/foo/g' 'bar'
verify 's/^a/foo/g' 'aaaa'

# p opt
verify 's/foo/bar/p;d' 'padding foo padding'
verify 's/foo/bar/pg;d' 'padding foo padding foo padding'
verify 's/foo/bar/gp;d' 'padding foo padding foo padding'
verify 's/^/hey/p;d' 'foo'
verify 's/^//p;d' 'foo'

# s with \n
verify 'N; s/^foo\nbar/yo\nlo/g' 'foo
bar'

# s empty match check
verify 's/[^ ]*/yo/g' 'Hello world'
verify 's/[^ ]*/yo/g' 'Hello '
verify 's/[^ ]*/yo/' 'foo'

# s insert at beginning and end
verify 's/^/Leading insert/' 'Hello World'
verify 's/$/Trailing insert/' 'Hello World'

# t
verify ': start; s/^[^[:blank:]]//; t start' 'Hello World'
# t, verify that reading a newline resets the substitution success to false
verify 't end; s/foo//; d; : end' 'foo
bar'
verify 's/.*/yo/; n; t end; p; : end; d' 'foo
bar'
verify 's/.*/yo/; N; t end; p; : end; d' 'foo
bar'

# b
verify ':start; s/.//; /^[^[:blank:]]/b start' 'Hello World'

# H and G
verify 'H;H;G;' 'Hello World'

# p and P
verify 'h; s/ World//; x; s/Hello //; H; s/.*/end/; H; g; p' 'Hello World'
verify 'h; s/ World//; x; s/Hello //; H; s/.*/end/; H; g; P' 'Hello World'

# = equal
verify '=' 'Abc'
verify '=' 'This line
is not a
single line'

# d and D
verify 's/Hello/foo/; t end; d; s/foo/bar/; :end' 'Hello
World
Hello
You'
verify 's/Hello/foo/; t end; D; s/foo/bar/; :end' 'Hello
World
Hello
You'
verify '/^hey/{=;q}; N; s/bar/hey/; D; s/.*/unreach/; p' 'foo
bar
baz'
verify '/match fail/d; s/foo/bar/' 'foo'

# n and N
verify 's/Hello/foo/; n; s/World/bar/; q' 'Hello
World'
verify ': start; s/^.//; N; b start' 'This line
is not a
single line'

# ultimate test, compile the translator and verify that the binary can become
# the translator
assert_true compile_translator -- 'translating the translator with a compiled translator yields the original translation'

verify 'i \
f"oo  \
b\jr\
b\\az\
b\nuf\
funk
s/Hello/Bye/' 'Hello
World'

# empty pattern
verify '/foo/s///' 'foo bar
funk'
verify '/foo/s///' 'foo bar
funk'
verify '/foo/{/funk/s//hey/}' 'foo funk'
verify 's/foo/bar/; s//funk/' 'foo foo foo'

verify '/foo/!s/f/z/' 'foo
bar
foo'
verify '/foo/!s/f/z/' 'foo bar foo'
verify '1!s/f/z/' 'foo
foo'
verify '1!s/f/z/' 'foo bar'

# ranges
verify '1,3s/^/x/' 'foo
bar
funk
fax'
verify '2,3s/^/x/' 'foo
bar
funk
fax'
verify '2,2s/^/x/' 'foo
bar
funk
fax'
verify '2,10s/^/x/' 'foo
bar
funk
fax'
verify '2,1s/^/x/' 'foo
bar
funk
fax'

verify '1,/bar/s/^/x/' 'foo
bar
funk
fax'

verify '/foo/,/funk/s/^/x/' 'foo
bar
funk
fax'

verify '\,foo,,/funk/s,^,x,' 'foo
bar
funk
fax'

verify '/foo/,\,funk,s,^,x,' 'foo
bar
funk
fax'

verify '\,foo,,\,funk,s,^,x,' 'foo
bar
funk
fax'

verify '/foo/,/funk/s/^/x/; 1n' 'foo
bar
funk
fax'

verify '/foo/,/bar/s/^/x/' 'foo
bar
funk
fax'

verify '/foo/,/bar/s/^/x/; 1n' 'foo
bar
funk
fax'

verify '/foo/,/non existing/s/^/x/' 'foo
bar
funk
fax'

verify '/foo/,3s/^/x/' 'foo
bar
funk
fax'

verify '/foo/,3s/^/x/; 1n;' 'foo
bar
funk
fax'

# Busybox v1.30.1 fails this one
verify '2!{1,2s/^/> /}' 'foo
bar
funk
fax'

verify 'a \
funk\
punk
s/^/x/
a \
yo\
yeah
s/^/y/
n
s/^/z/' 'foo
bar
baz
funk'

verify '$s/^/last line: /' 'foo
bar
baz'

verify '${s/^/last line: /; p}' 'foo
bar
baz'

verify '$,1s/^/last line: /' 'foo
bar
baz'

verify '2,$s/^/not first: /' 'foo
bar
baz
funk'

verify '/bar/,$s/^/after bar: /' 'foo
bar
baz
funk'

verify '/bar/,${s/^/after bar: /}' 'foo
bar
baz
funk'

verify '$,/funk/s/^/between last line and funk: /' 'foo
bar
baz
funk'

verify '$,/non-existing/s/^/between last line and some non matching regex: /' 'foo
bar
baz
funk'

verify 'c \
punk\
dunk
s/^/x/' 'foo
bar
baz
funk'

verify 'y/abc/def/' 'abbac'
verify 'y abc def ' 'abbac'
verify 'ya\abcadefa' 'abbac'
verify 'h; y/abc/def/; h' 'abbac'

end_tests
