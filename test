#!/bin/sh

. "${CLASH_ROOT-.}"/test/testlib/assert || exit

bin=./sed-bin
translator=./par.sed
generated_file=generated.c

trap 'rm -f "$bin_output" "$expected_output"' EXIT
expected_output="$(mktemp)"
bin_output="$(mktemp)"

compile_translator() {
  # Tranlate the translator with itself
  "$translator" < "$translator" > "$generated_file" &&
  make -s &&
  # Compiled tranlator should be able to translate the translator and yield the
  # exact same output
  "$bin" < "$translator" > "$bin_output" &&
  diff --side-by-side --suppress-common-lines "$generated_file" "$bin_output"
}

equal_output() {
  echo --------------------------

  printf '%s\n' "$input" | sed "$sed_code" > "$expected_output" &&
  printf '%s\n' "$sed_code" | "$translator" > "$generated_file" &&
  make -s &&
  printf '%s\n' "$input" | "$bin" > "$bin_output" &&
  diff --side-by-side "$expected_output" "$bin_output"
}

verify() {
  sed_code="$1"
  input="$2"

  assert_true equal_output "$sed_code" -- "input: $input"
  echo ==========================
}

# Replace by smaller
verify 's/Hell/Y/' 'Hello World'
verify 's/llo W/y w/' 'Hello World'
verify 's/ World/!/' 'Hello World'
# Replace by bigger
verify 's/Hello/What in the/' 'Hello World'
verify 's/o/ what is wrong with this/' 'Hello World'
verify 's/ld/k! Oh no :(/' 'Hello World'
# Replace by same size
verify 's/Hello/Yolo!/' 'Hello World'
verify 's/o/a/' 'Hello World'
verify 's/ld/k!/' 'Hello World'
# With regex
verify 's/[hH]/Well h/' 'Hello World'
verify 's/. ./a-w/' 'Hello World'
verify 's/o.*/!/' 'Hello World'
verify 's/.*//' 'Hello World'
verify 's/.*/Bye/' 'Hello World'
verify 's/[Hh]ello.* World*//' 'Hello World'
verify 's/Hello World/Bye/' 'Hello World'
verify 's/Hello World//' 'Hello World'
# Fail
verify 's/xz/nope/' 'Hello World'
# Back refs
verify 's/\([^ ]*\)/\1! \1/' 'Hello World'
verify 's/\([^ ]*\) \(.\)/\1! \2 /' 'Hello World'
verify 's/.*r/& & &/' 'Hello World'
verify 's/Hello/\& literal ampersand/' 'Hello World'
# g opt
verify 's/o/a/g' 'Hello World'
verify 's/o/abocde/g' 'Hello World'
verify 's/o/ yo/g' 'Hello World'
verify 's/damn/no/g' 'Oh damn god damnit'
verify 's/damn/n/g' 'Oh damn god damnit'
verify 's/.*/Bye/g' 'Hello World'
verify 's/\([^ ]*\)/\1! \1/g' 'Hello World'
verify 's/[^a]/foo/g' 'bar'
verify 's/^a/foo/g' 'aaaa'

# s empty match check
verify 's/[^ ]*/yo/g' 'Hello world'
verify 's/[^ ]*/yo/g' 'Hello '
verify 's/[^ ]*/yo/' 'foo'

# s insert at beginning and end
verify 's/^/Leading insert/' 'Hello World'
verify 's/$/Trailing insert/' 'Hello World'

# t
verify ': start; s/^[^[:blank:]]//; t start' 'Hello World'
# t, verify that reading a newline resets the substitution success to false
verify 't end; s/foo//; d; : end' 'foo
bar'
verify 's/.*/yo/; n; t end; p; : end; d' 'foo
bar'
verify 's/.*/yo/; N; t end; p; : end; d' 'foo
bar'

# b
verify ':start; s/.//; /^[^[:blank:]]/b start' 'Hello World'

# H and G
verify 'H;H;G;' 'Hello World'

# p and P
verify 'h; s/ World//; x; s/Hello //; H; s/.*/end/; H; g; p' 'Hello World'
verify 'h; s/ World//; x; s/Hello //; H; s/.*/end/; H; g; P' 'Hello World'

# = equal
verify '=' 'Abc'
verify '=' 'This line
is not a
single line'

# d and D
verify 's/Hello/foo/; t end; d; s/foo/bar/; :end' 'Hello
World
Hello
You'
verify 's/Hello/foo/; t end; D; s/foo/bar/; :end' 'Hello
World
Hello
You'
verify '/^hey/{=;q}; N; s/bar/hey/; D; s/.*/unreach/; p' 'foo
bar
baz'

# n and N
verify 's/Hello/foo/; n; s/World/bar/; q' 'Hello
World'
verify ': start; s/^.//; N; b start' 'This line
is not a
single line'

# ultimate test, compile the translator and verify that the binary can become
# the translator
assert_true compile_translator -- 'translating the translator with a compiled translator yields the original translation'

end_tests
